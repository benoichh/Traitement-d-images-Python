from PIL.Image import *
import sys

#Fonction exécuter lorsque l'on lance le programme
def Start():
	image = sys.argv[1]
	reconize(image)


#Fonction permettant de charger une image
def ChargeImage(link):
	img = open(link)
	return img

#Fonction permettant de calculer la distance euclidienne entre 2 points
def eucl(x1,y1,x2,y2):
	return ((x1-x2)**2+(y1-y2)**2)**0.5

#Fonction permettant de reconnaître la censure en essaynt de trouver des pixels de même couleurs côte à côte
def reconize(link):

	img = ChargeImage(link)
	pixR = img.load()
	thumb = img.copy()
	pix = thumb.load()

	list_X = []
	list_Y = []	

	#Reconnaître des pixels similaires côte à côte
	for x in range(img.size[0]-10):
		for y in range(img.size[1]-10):

			if(pix[x,y] != (0,0,255)):

				cmpt = 0

				for xp in range(x,x+10):
					for yp in range(y,y+10):
						if(soustraction(pixR[xp,yp],pixR[x,y]) <= 5):
							cmpt += 1

				if(cmpt >= 90):
					for xp in range(x,x+10):
						for yp in range(y,y+10):
							list_X.append(xp)
							list_Y.append(yp)
							
	

	for i in range(len(list_X)):
		X = list_X[i]
		Y = list_Y[i]

		pix[X,Y] = 0,0,255							


    #Reconnaître des rectangle à 90% de bleu
	for x in range(img.size[0]-10):
		for y in range(img.size[1]-10):
			
			if(pix[x,y] == (0,0,255)):
	
				cmpt2 = 0

				for xp in range(x,x+10):
					for yp in range(y,y+10):
						if(pix[xp,yp]==(0,0,255)):
							cmpt2 += 1
			
				if(cmpt2 >= 91):
					for xp in range(x,x+10):
						for yp in range(y,y+10):
							pix[xp, yp] = 0,0,255
	


	#Succession des carrés de censure (marche pas)
	for x in range(img.size[0]-20):
		for y in range(img.size[1]-20):
			
			Xb,Yb = 0,0
			Xp,Yp = 0,0				
			
			for xp in range(x,x+20):
				for yp in range(y,y+20):

					if(pix[xp,yp] == 0,0,255): 
						if(Xb,Yb == 0,0):
							Xb,Yb = xp,yp

					if(pix[xp,yp] == 0,0,255): 
						if(eucl(Xb,Yb,xp,yp) > 20):
							Xp,Yp = xp,yp
					
					if(eucl(Xb,Yb,Xp,Yp) > 5): 
						if(eucl(Xb,Yb,Xp,Yp) < 40):
						
							print("Yes")				
							
							for xf in range(Xb,Xp):
								for yf in range(Yb,Yp):
									pix[xf,yf] = 0,0,255

							Xb,Yb = 0,0
						
					
			





	thumb.show()
	pass


#Fonction permettant la soustraction entre 2 pixels
def soustraction(pix1, pix2):

	R1,G1,B1 = pix1
	R2,G2,B2 = pix2
	
	R = abs(R1-R2)
	G = abs(G1-G2)
	B = abs(B1-B2)
	
	#pix3 = R,G,B
	total = R+G+B
	
	#return pix3
	return total




Start()




#Questions:

#Il n'y a pas de valeur universelle permettant de détecter la censure. Sur certaines photo c'est trop, d'autre pas assez... Comment faire ?
Faire des stats

#D'autre technique que le rectangle et les pixels pour detecter la censure ?
Detecter succecion de carré de censure

#Comment détecter des suites de carré de censure ?
A faire

#Comment éviter de détecter un fond d'image uniform non censuré ?
Grâce a un seuil de carré bleu 

#Faire une liste des coordonnées au lieu de les passer directe en bleu?
Fait








#liens utiles:

#Pour détecter et censurer automatiquement:

#https://github.com/topics/nudity-detection?l=python
#https://www.programmableweb.com/news/detect-nudity-api-automates-image-censorship/brief/2015/03/31
#https://www.programmableweb.com/api/detect-nudity
#https://blog.algorithmia.com/censor-faces-with-video-processing-algorithms/
#https://blog.algorithmia.com/censoring-faces-automatically/

#Pour reconstituer une image censurée:

#https://www.bogotobogo.com/python/OpenCV_Python/python_opencv3_Image_reconstruction_Inpainting_Interpolation.php
#https://github.com/cwg45/Image-Reconstruction
#https://stats.stackexchange.com/questions/62416/image-reconstruction-using-compressed-sensing
